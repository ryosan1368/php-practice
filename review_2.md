# PHP練習問題② 説明

## 下記for文の`$i = 0`, `$i <= 4`, `$i++`, `echo $i`がそれぞれ、どの順番で処理されるか、また、何をしているのかを説明してください。

```
for ($i = 0; $i <= 4; $i++) {
    echo $i;
}
```

1. `$i = 0`
初期値を設定しています。
一回目の処理でしか行われません。

2. `$i <= 4`
変数$iに代入されている値が4以下かどうか判定しています。
この部分は条件式と言い、条件が真になる（条件が成立する）限りは処理を実行します。

3. `echo $i`
処理の内容が書かれています。
条件式が真の場合、$iに代入された値を出力する処理が行われます。

4. `$i++`
波括弧の中に書かれた処理が終わったあとに実行される処理です。
この部分は更新式と言い、$i++は現在の値に+1するという内容になります。
また、-1する場合は$i--と書くことができ、1を足すことをインクリメント、1を引くことをデクリメントと呼びます。


## for文とforeachはどのように使い分けるのか説明してください。
- forは、配列のデータに対して、処理を繰り返したい時に使いますが、foreachは、連想配列のデータに対して、処理を繰り返したい時に使います。

- "foreach ($配列の変数 as $キー => $バリュー) {処理の内容}" と書くことで配列の中の全ての要素に{}の処理が行われます。処理が実行される順番は、配列の最初の要素から始まり、順に取り出して反復処理（ループ処理）を行います。この反復処理のことは「回す」と表現されたりします。

また、$キーと$バリューの部分は自由に命名可能で、キーを使わない時は省略することもできるため、見やすくわかりやすい書き方をするといいでしょう。

## クラスとインスタンスの違いについて説明してください。
- クラスとは、処理をまとめた設計図のようなものです。データとそれに関連する処理を１つにまとめて管理することができ、書き方は「class クラス名 {処理内容}」と書きます。

- そして、クラスを作るだけでは処理は動かないので、処理を実行させるためにクラスを基にオブジェクトを作ること、すなわち「インスタンス化」する必要があります。インスタンス化するコードの書き方は、まずクラスを作り、クラスの波括弧の後に「$変数 = new インスタンス化したいクラス名 (); 」と書きます。

ちなみに、処理をまとめるといえば関数もありますが、関数はシンプルなデータを扱ったり単純な処理をする場合に向いていて、反対に、クラスは多数のデータを扱ったり複雑な処理をする場合に向いています。

## プロパティとメソッドとはなにか説明してください。
- まず、オブジェクト型のデータにはクラスという枠組みが作られます。
その中に定義された変数のことを「プロパティ」、関数のことを「メソッド」と言います。（プロパティは「メンバ変数」と呼ぶこともあります。）

- プロパティは、クラスの波括弧の中に「public $変数名 = 任意の文字列や数値;」と書くことで定義でき、通常の変数と違って空の状態（「public $変数名」だけ書くこと）で定義することもできます。
- メソッドは、クラスの波括弧の中に「public function 関数名() {処理内容;}」と書くことで定義でき、（）の中に引数を渡すこともできます。

クラス内で定義する時は「アクセス修飾子」を頭に付ける以外は、通常の定義と同じ書き方になります。（ちなみに今回使ったのはpublicで、スコープに基づいてどこからでもアクセス可能ですよと定義するものです。）


## コンストラクタとはなにか、また、なぜ必要なのかを説明してください。
- コンストラクタとは、クラスをインスタンス化した時に実行される特殊なメソッドです。クラスの中に「public function __construct(引数) {処理内容;}」と書くことで定義できます。

```
（例）
class User
{
    public $userName;
    public $userAge;

    public function __construct($name, $age)
    {
        $this->userName = $name;
        $this->userAge = $age;
    }

    public function userInfo()
    {
        echo $this->userName . 'の年齢は' . $this->userAge . '歳です。';
    }
}

$sasaki = new User('佐々木', 20);
$sasaki->userInfo();
```
上記のコードでは$sasaki = new User('佐々木', 20); と書いてインスタンス化した際に、コンストラクタは自動的に実行されます。そして、コンストラクタは引数として受け取った$name（'佐々木'）と$age（20）をプロパティの$userNameと$userAgeへそれぞれ設定します。

- このように、コンストラクタはオブジェクトの初期設定ができ、また、オブジェクトごとに引数から値を持たせることができるため、柔軟性の高い処理が求められる際は必要になるのです。


## 下記コンストラクター内の2行が何をしているのか、また、なぜこの2行が必要なのか説明してください。
```
public function __construct($id, $name)
{
    $this->studentId = $id;
    $this->studentName = $name;
}
```
- 上記のコンストラクタ内のコードは、$idと$nameにクラスの外から引数が渡された後、今動かしている変数を指す$thisから、アロー演算子（->）を使ってクラス内プロパティである$studentIdと$studentNameにアクセスして代入しています。

例えば、$idに学籍番号：10・$nameに名前：'田中'という値を渡す時、コンストラクタは10を$studentIdへ代入し、'田中'を$studentNameへ代入するということです。

- この2行は、様々なデータの登録を、正確に行うために必要なものになります。
先ほどの例を用いて説明すると、引数で渡した値がコンストラクタ内でクラスのプロパティに代入されるというのは、すなわち、学籍番号や名前のデータがプロパティに格納（登録）されるということです。

- もしこの2行がなければ、データを登録する度に定義したり、処理を書いたりすることになります。そうするとコードを書き間違えるリスクは高まり、時間もかかってしまうでしょう。


## クラスがなぜ必要なのか説明してください。
- クラスがなぜ必要なのかを考えるには、クラスの持つ利点から考えるとわかりやすいでしょう。

- クラスの利点とは、データとそれに関連する処理を１つにまとめられるため、プログラムが大きくなっても整理しやすい点や、クラスを使いまわせば複数のオブジェクトを簡単に作れる点などがあります。

- つまり、膨大な量のデータや複雑な処理を相手にする時は、クラスが必要不可欠な存在になるということです。

## `DateTime::modify`メソッドの返り値を教えてください。
- 下記のコードを例に返り値を確認してみましょう。
```
$time = new DateTime();
$time->setTimezone(new DateTImeZone('Asia/Tokyo'));
echo $time->modify('-1 months')->format('Y-m-d');
```

- まず、１行目では定義済みクラスの一つであるDateTimeをインスタンス化し、$timeに代入しています。DateTimeは現在時刻を取得するクラスです。続いて２行目では、タイムゾーンを日本時間に設定しています。３行目は、取得した現在時刻から１か月分マイナスし、その結果をYYYY-mm-ddの形式で出力するという処理が書かれています。

- `DateTime::modify`メソッドは、$time->modify('-1 months')といった書き方をし、日付や時刻の加算や減算する内容を引数に渡します。
そのため、計算後の日付や時刻が返り値として、引数を渡した箇所へ戻ってきます。

## `DateTime::format`メソッドと`DateInterval::format`メソッドの違いを教えてください。
- `DateTime::format`メソッドは、DateTimeオブジェクトで取得した日付と時間を、フォーマット（表示形式）を指定して変換するメソッドです。

- `DateInterval::format`メソッドは、DateIntervalオブジェクトで取得した日付の間隔を、日付と時間のフォーマット（表示形式）を指定して変換するメソッドです。

- フォーマットを設定することで表されるのが、「特定の日付や時間」なのか、「２つの日時の差などのある一定の期間（間隔）」なのかという部分が、この２つのメソッドの違いだと言えます。

## 下記コード3行目のformatメソッドの返り値をPHPのマニュアルから調べる手順を具体的に説明してください。
```
$now = new DateTime();
$prev = new DateTime('2000-1-1');
echo $prev->diff($now)->format('%a')
```

- まず、このコードはDateTimeクラスを利用していることと、３行目のコードはメソッドチェインになっており、formatメソッドは直前に書かれているdiffメソッドの処理結果を引き継いでいることに注目します。

- PHPマニュアルのサイトの検索欄はスペースを空ければ検索結果を絞ることができるので「DateTime diff」と入れてみましょう。すると、「DateTimeInterface::diff」というページがヒットします。ページを開くと、diffメソッドの説明が書かれています。

- 次は、そのページを開いた状態で検索欄に「format」と入れると、「DateInterval::format」という項目が見つかるので開いてみましょう。
（ちなみに、検索欄を使わなくてもDateTimeInterface::diffページの下の方にある参考という項目の「DateInterval::format() - 間隔をフォーマットする」という部分を開いても同じページにたどり着きます。）

- DateInterval::formatのページで戻り値という項目を確認します。戻り値＝返り値ですので、formatメソッドの返り値は「フォーマットされた間隔を返します。」ということになります。フォーマットされた間隔というのはすなわち、フォーマットされたdiffメソッドが取得した日時の差（間隔）を返す、ということです。

- 上記のコードの場合は、$nowと$prevの日付の差を、%aという形式で表し、その値を返すということになりますが、DateInterval::formatのページのパラメータという項目を確認すると、「フォーマット文字は、パーセント記号 (%) で始めなければなりません。」とあることから、形式を表す文字列は「a」であるとわかります。そしてその「a」の説明は「DateTime::diff() の結果に使った場合は総日数、それ以外の場合は (unknown)」とあります。

- つまり、上記のコードの返り値は、diffメソッドが取得した日時の差（間隔）を日数で表した値となります。